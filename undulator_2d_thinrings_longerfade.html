<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Undulator — 2D: thin rings, longer fade</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      background: #0b1020;
      color: #e6e6e6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #hero { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    #overlay {
      position: absolute; top: 12px; left: 12px; z-index: 10;
      background: rgba(0,0,0,0.35);
      padding: 8px 10px; border-radius: 8px;
      font-size: 14px; line-height: 1.35;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    #wiggler-canvas { width: 100%; height: 100%; display: block; }
    .legend-badge { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
  </style>
</head>
<body>
  <div id="hero">
    <div id="overlay">
      <div><span class="legend-badge" style="background:#00BFFF"></span>Electron (2D)</div>
      <div><span class="legend-badge" style="background:#ff5555"></span>North magnet</div>
      <div><span class="legend-badge" style="background:#5555ff"></span>South magnet</div>
      <div><span class="legend-badge" style="background:#ffd700"></span>Thin expanding circles (slower fade)</div>
    </div>
    <canvas id="wiggler-canvas"></canvas>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

  <script>
    // --- Renderer ---
    const scene = new THREE.Scene();
    const canvas = document.getElementById('wiggler-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);

    // --- Parameters ---
    const magnetCount = 20;
    const magnetSpacing = 2.0;
    const undulatorWidth = (magnetCount - 1) * magnetSpacing;
    const startX = -undulatorWidth / 2;
    const undulatorLambda = 2.0 * magnetSpacing; // one full oscillation in x

    const amplitude = 0.2;
    const frequency = Math.PI / magnetSpacing; // y(x) = A cos(frequency * x)
    const electronSpeed = 4;            // electron forward speed

    // Circle emission & animation parameters (tuned)
    const circleSpeedFactor = 1.10;     // circle moves slightly faster than electron
    const circleSpeed = electronSpeed * circleSpeedFactor;
    const ringR0 = 0.22;                // initial radius (slightly bigger than electron ~0.15)
    const ringGrowthSpeed = 1.6;        // how fast radius increases (units/sec)
    const ringLifespan = 3.8;           // longer life (seconds)
    const ringMaxCount = 30;            // keep only the most recent N circles
    const ringThickness = 0.015;        // *** thinner band ***

    // --- 2D Orthographic Camera (auto-fit) ---
    let camera;
    function fitOrthoCamera() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const aspect = w / h;

      // Horizontal extents: undulator + margins so first/last period are visible
      const xMargin = 0.6 * magnetSpacing;
      const xMin = startX - xMargin;
      const xMax = startX + undulatorWidth + xMargin;
      const halfWidth = 0.5 * (xMax - xMin);

      // Vertical extents: include magnets and max ring expansion
      const maxRingRadius = ringR0 + ringGrowthSpeed * ringLifespan + ringThickness;
      const magnetTopEdge = 1.5 + 0.75 * 0.5;
      const magnetBottomEdge = -2.5 - 0.75 * 0.5;
      const yMargin = 0.25;
      const yHalfNeeded = Math.max(
        Math.abs(magnetTopEdge),
        Math.abs(magnetBottomEdge),
        Math.abs(amplitude) + maxRingRadius
      ) + yMargin;

      const halfHeightFromX = halfWidth / aspect;
      const viewHalfHeight = Math.max(yHalfNeeded, halfHeightFromX);
      const viewHalfWidth  = viewHalfHeight * aspect;

      if (!camera) {
        camera = new THREE.OrthographicCamera(
          -viewHalfWidth, viewHalfWidth,
          viewHalfHeight, -viewHalfHeight,
          -100, 100
        );
      } else {
        camera.left   = -viewHalfWidth;
        camera.right  =  viewHalfWidth;
        camera.top    =  viewHalfHeight;
        camera.bottom = -viewHalfHeight;
        camera.updateProjectionMatrix();
      }
      camera.position.set((xMin + xMax)/2, 0, 10);
      camera.lookAt((xMin + xMax)/2, 0, 0);
    }
    fitOrthoCamera();

    // --- Magnets (2D rectangles) ---
    const magnetGroup = new THREE.Group();
    const magW = 0.75, magH = 0.75;
    const planeGeom = new THREE.PlaneGeometry(magW, magH);
    const redMat  = new THREE.MeshBasicMaterial({ color: 0xff5555 });
    const blueMat = new THREE.MeshBasicMaterial({ color: 0x5555ff });
    for (let i = 0; i < magnetCount; i++) {
      const xPos = startX + i * magnetSpacing;
      const topIsRed = i % 2 === 0;
      const up = new THREE.Mesh(planeGeom, topIsRed ? redMat : blueMat);
      up.position.set(xPos,  1.5, 0);
      magnetGroup.add(up);
      const dn = new THREE.Mesh(planeGeom, topIsRed ? blueMat : redMat);
      dn.position.set(xPos, -2.5, 0);
      magnetGroup.add(dn);
    }
    scene.add(magnetGroup);

    // --- Electron (2D circle) ---
    const electron = new THREE.Mesh(
      new THREE.CircleGeometry(0.15, 32),
      new THREE.MeshBasicMaterial({ color: '#00BFFF' })
    );
    scene.add(electron);

    // --- Thin Ring template ---
    function makeRingMesh() {
      const geom = new THREE.RingGeometry(ringR0 - ringThickness, ringR0 + ringThickness, 256);
      const mat = new THREE.MeshBasicMaterial({
        color: 0xffd700,
        transparent: true,
        opacity: 0.95,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });
      return new THREE.Mesh(geom, mat);
    }

    // --- Circle (ring) instance state ---
    const rings = []; // { mesh, birthTime, birthAbsX }
    let lastEmittedPeriodIndex = -1;

    // --- Helpers for wrapping x into visible window ---
    function wrapToWindow(absX) {
      const mod = ((absX - startX) % undulatorWidth + undulatorWidth) % undulatorWidth;
      return startX + mod;
    }

    // --- Animation ---
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // Electron absolute distance
      const absDist = t * electronSpeed;
      const eProgress = absDist % undulatorWidth;
      const x_e = startX + eProgress;
      const y_e = amplitude * Math.cos(frequency * eProgress);
      electron.position.set(x_e, y_e, 0);

      // Emit a new ring once per undulator period
      const periodIndex = Math.floor(absDist / undulatorLambda);
      if (periodIndex !== lastEmittedPeriodIndex) {
        lastEmittedPeriodIndex = periodIndex;
        const ring = makeRingMesh();
        ring.userData.birthTime = t;
        ring.userData.birthAbsX = x_e; // absolute x at emission
        scene.add(ring);
        rings.push(ring);
        if (rings.length > ringMaxCount) {
          const old = rings.shift();
          scene.remove(old);
          old.geometry.dispose();
          old.material.dispose();
        }
      }

      // Update rings
      for (let i = rings.length - 1; i >= 0; i--) {
        const r = rings[i];
        const age = t - r.userData.birthTime;

        // Motion along x with slight lead
        const x_abs = r.userData.birthAbsX + circleSpeed * age;
        const x_loc = wrapToWindow(x_abs);
        const y_loc = amplitude * Math.cos(frequency * ((x_loc - startX) % undulatorWidth));
        r.position.set(x_loc, y_loc, 0);

        // Expansion
        const radius = ringR0 + ringGrowthSpeed * age;
        const scale = radius / ringR0;
        r.scale.set(scale, scale, 1);

        // Slower, ease‑out fading (stays brighter longer)
        const u = Math.min(1, age / ringLifespan);
        const easeOut = 1.0 - Math.pow(u, 1.5); // bias brightness toward early life
        r.material.opacity = 0.95 * easeOut;

        // Cleanup when fully faded
        if (u >= 1.0) {
          scene.remove(r);
          rings.splice(i, 1);
          r.geometry.dispose();
          r.material.dispose();
        }
      }

      renderer.render(scene, camera);
    }

    // --- Resize handling ---
    function onResize() {
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      fitOrthoCamera();
    }
    window.addEventListener('resize', onResize, false);
    onResize();
    animate();
  </script>
</body>
</html>
