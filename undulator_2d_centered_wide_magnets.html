<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Undulator — 2D: centered electron & wide magnets</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background:#0b1020; color:#e6e6e6; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    #hero { position:relative; width:100vw; height:100vh; overflow:hidden; }
    #overlay {
      position:absolute; top:12px; left:12px; z-index:10;
      background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px;
      font-size:14px; line-height:1.35; -webkit-backdrop-filter:blur(6px); backdrop-filter:blur(6px);
    }
    #wiggler-canvas { width:100%; height:100%; display:block; }
    .legend-badge { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
  </style>
</head>
<body>
  <div id="hero">
    <div id="overlay">
      <div><span class="legend-badge" style="background:#00BFFF"></span>Electron centered between rows</div>
      <div><span class="legend-badge" style="background:#ff5555"></span>North magnet (wider)</div>
      <div><span class="legend-badge" style="background:#5555ff"></span>South magnet (wider)</div>
      <div><span class="legend-badge" style="background:#ffd700"></span>Expanding rings (only in module)</div>
    </div>
    <canvas id="wiggler-canvas"></canvas>
  </div>

  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script>
    // --- Renderer ---
    const scene = new THREE.Scene();
    const canvas = document.getElementById('wiggler-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight, false);

    // --- Parameters ---
    const magnetCount   = 20;
    const magnetSpacing = 2.0;
    const undulatorWidth = (magnetCount - 1) * magnetSpacing; // module length
    const startX = -undulatorWidth / 2;
    const endX   =  startX + undulatorWidth;
    const undulatorLambda = 2.0 * magnetSpacing;

    // Place magnet rows symmetrically about y=0 so the electron center is in the middle
    const magnetYTop    =  2.0;
    const magnetYBottom = -2.0;
    const yCenter = 0.5 * (magnetYTop + magnetYBottom); // = 0.0

    // Make magnets wider: almost no gap between adjacent magnets
    const gapFraction = 0.04;                          // 4% gap of spacing
    const magW = magnetSpacing * (1.0 - gapFraction);  // very small gap
    const magH = 0.9;                                   // a touch taller than before

    // Electron oscillation
    const amplitude = 0.25;                             // about the center between rows
    const k = Math.PI / magnetSpacing;                  // = 2π / λ_u
    const electronSpeed = 5;

    // Drift settings (outside module)
    const driftLeft  = 6.0;
    const driftRight = 6.0;
    const edgeBlend  = 0.6;   // smooth transition width

    // Loop reset (off-screen)
    const offscreenPad = 8.0;

    // Circles
    const circleSpeedFactor = 0.65;
    const circleSpeed = electronSpeed * circleSpeedFactor;
    const ringR0 = 0.2;
    const ringGrowthSpeed = 2.0;
    const ringLifespan = 7.0;
    const ringMaxCount = 120;
    const ringThickness = 0.008;
    const fadeExponent = 1.5;
    const startOpacity = 0.95;

    // --- Camera (fit everything) ---
    let camera;
    function fitOrthoCamera(){
      const w = canvas.clientWidth, h = canvas.clientHeight, aspect = w/h;

      const xMinScene = startX - driftLeft;
      const xMaxScene = endX   + driftRight;
      const halfWidth = 0.5 * (xMaxScene - xMinScene);

      const maxRingRadius = ringR0 + ringGrowthSpeed * ringLifespan + ringThickness;
      const magnetTopEdge = magnetYTop + magH * 0.5;
      const magnetBottomEdge = magnetYBottom - magH * 0.5;
      const yHalfNeeded = Math.max(Math.abs(magnetTopEdge), Math.abs(magnetBottomEdge), Math.abs(yCenter) + amplitude + maxRingRadius) + 0.25;

      const viewHalfHeight = Math.max(yHalfNeeded, halfWidth/aspect);
      const viewHalfWidth  = viewHalfHeight * aspect;

      if (!camera) camera = new THREE.OrthographicCamera(-viewHalfWidth, viewHalfWidth, viewHalfHeight, -viewHalfHeight, -100, 100);
      else { camera.left=-viewHalfWidth; camera.right=viewHalfWidth; camera.top=viewHalfHeight; camera.bottom=-viewHalfHeight; camera.updateProjectionMatrix(); }
      camera.position.set((xMinScene+xMaxScene)/2, 0, 10); camera.lookAt((xMinScene+xMaxScene)/2, 0, 0);
    }
    fitOrthoCamera();

    // --- Magnets (2D) ---
    const magnetGroup = new THREE.Group();
    const planeGeom = new THREE.PlaneGeometry(magW, magH);
    const redMat  = new THREE.MeshBasicMaterial({ color: 0xff5555 });
    const blueMat = new THREE.MeshBasicMaterial({ color: 0x5555ff });
    for (let i=0;i<magnetCount;i++){
      const x = startX + i*magnetSpacing;
      const topIsRed = i%2===0;
      const up = new THREE.Mesh(planeGeom, topIsRed?redMat:blueMat);
      up.position.set(x, magnetYTop, 0); magnetGroup.add(up);
      const dn = new THREE.Mesh(planeGeom, topIsRed?blueMat:redMat);
      dn.position.set(x, magnetYBottom, 0); magnetGroup.add(dn);
    }
    scene.add(magnetGroup);

    // --- Electron ---
    const electron = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), new THREE.MeshBasicMaterial({ color:'#00BFFF' }));
    scene.add(electron);

    // --- Ring factory ---
    function makeRing(){
      const geom = new THREE.RingGeometry(ringR0 - ringThickness, ringR0 + ringThickness, 256);
      const mat  = new THREE.MeshBasicMaterial({ color:0xffd700, transparent:true, opacity:startOpacity, depthWrite:false, blending:THREE.AdditiveBlending, side:THREE.DoubleSide });
      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      return mesh;
    }

    // --- Helpers ---
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function smoothstep(e0, e1, x){ const t = clamp01((x-e0)/(e1-e0)); return t*t*(3.0 - 2.0*t); }

    // y(x_abs): cosine inside module around yCenter; straight (≈yCenter) outside with smooth edges
    function yPath(x_abs){
      const gateIn  = smoothstep(startX,       startX + edgeBlend, x_abs);
      const gateOut = 1.0 - smoothstep(endX - edgeBlend, endX,     x_abs);
      const gate = Math.min(gateIn, gateOut);
      return yCenter + gate * amplitude * Math.cos(k * (x_abs - startX));
    }

    // --- State ---
    const rings = []; // { mesh, birthTime, birthAbsX }
    let lastPeriodIdx = -1;
    let x0 = startX - driftLeft - offscreenPad;
    let t0 = 0;

    // --- Animation ---
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      const x_abs_e = x0 + electronSpeed*(t - t0);
      const y_e = yPath(x_abs_e);
      electron.position.set(x_abs_e, y_e, 0);

      // Emit rings only inside module
      if (x_abs_e >= startX && x_abs_e <= endX) {
        const periodsFromLeft = (x_abs_e - startX) / undulatorLambda;
        const periodIdx = Math.floor(periodsFromLeft + 1e-6);
        if (periodIdx !== lastPeriodIdx){
          lastPeriodIdx = periodIdx;
          const ring = makeRing();
          ring.userData.birthTime = t;
          ring.userData.birthAbsX = x_abs_e;
          rings.push(ring);
          if (rings.length > ringMaxCount){ const old = rings.shift(); cleanupRing(old); }
        }
      } else {
        lastPeriodIdx = -1;
      }

      // Update rings
      for (let i=rings.length-1; i>=0; i--){
        const r = rings[i];
        const age = t - r.userData.birthTime;

        const x_abs = r.userData.birthAbsX + circleSpeed * age;
        const y     = yPath(x_abs);
        r.position.set(x_abs, y, 0);

        const radius = ringR0 + ringGrowthSpeed * age;
        const scale  = radius / ringR0;
        r.scale.set(scale, scale, 1);

        const u = Math.min(1, age / ringLifespan);
        const easeOut = 1.0 - Math.pow(u, fadeExponent);
        r.material.opacity = Math.max(0.0, startOpacity * easeOut);

        if (u >= 1){ cleanupRing(r); rings.splice(i,1); }
      }

      // Loop reset when far to the right
      const sceneRight = endX + driftRight;
      if (x_abs_e > sceneRight + offscreenPad){
        x0 = startX - driftLeft - offscreenPad;
        t0 = t;
      }

      renderer.render(scene, camera);
    }

    function cleanupRing(r){ scene.remove(r); r.geometry.dispose(); r.material.dispose(); }

    // --- Resize ---
    function onResize(){ renderer.setSize(window.innerWidth, window.innerHeight, false); fitOrthoCamera(); }
    window.addEventListener('resize', onResize, false);
    onResize();
    animate();
  </script>
</body>
</html>
