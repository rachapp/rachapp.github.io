<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P. Pongchalee | Physicist & Researcher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Styles for the new About Me section with Avatar --- */
        #about .about-container {
            display: flex;
            align-items: flex-start;
            gap: 50px;
        }

        #about .about-avatar {
            flex-shrink: 0;
            text-align: center;
        }

        #about .about-avatar img {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 3px solid var(--primary-color);
            background-color: var(--bg-content);
            padding: 5px;
        }
        
        #about .about-text .section-title,
        #about .about-text .section-subtitle {
            text-align: left;
            margin-left: 0;
            margin-right: 0;
            max-width: 100%;
        }

        #about .about-text h3 {
            margin-top: 1.5rem;
            color: var(--primary-color);
        }

        /* --- Styles for the WebGL Canvas --- */
        #hero {
            position: relative; /* Needed for absolute positioning of canvas */
            overflow: hidden; /* Hide anything that goes outside the hero area */
        }

        #wiggler-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Place canvas behind the text */
        }

        #hero .container {
            position: relative; /* Ensure text container is on top */
            z-index: 2;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #about .about-container {
                flex-direction: column;
                align-items: center;
                gap: 30px;
            }

            #about .about-text .section-title,
            #about .about-text .section-subtitle {
                text-align: center;
            }
        }
    </style>
</head>
<body style="background-color: var(--bg-main);">

    <header class="navbar">
        <div class="container">
            <a href="index.html" class="logo">P. Pongchalee</a>
            <nav>
                <ul class="nav-links">
                    <li><a href="index.html" class="active">Home</a></li>
                    <li><a href="research.html">Research</a></li>
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <!-- Hero Section with WebGL Canvas -->
        <section id="hero">
            <canvas id="wiggler-canvas"></canvas>
            <div class="container">
                <h1>Advancing Science with Light & Code</h1>
                <p class="section-subtitle" style="color: white; font-size: 1.2rem;">A physicist specializing in synchrotron instrumentation and computational modeling to develop and optimize next-generation light sources..</p>
            </div>
        </section>

        <!-- About Section -->
        <section id="about">
            <div class="container about-container">
                <div class="about-avatar">
                    <img src="https://api.dicebear.com/9.x/notionists/svg?seed=Katherine&backgroundType=gradientLinear&backgroundRotation=0,360,40&beard[]&body=variant20&bodyIcon[]&gesture[]&glasses=variant11&glassesProbability=100&hair=variant01,variant03,variant05,variant07,variant11,variant12,variant15&lips=variant02,variant03,variant04,variant05,variant06,variant07,variant08,variant09,variant10,variant11,variant12,variant13,variant14,variant15,variant16,variant17,variant18,variant19,variant20,variant21,variant22,variant23,variant24,variant25,variant26,variant27,variant28,variant29,variant30,variant01&backgroundColor=d1d4f9" alt="Avatar for P. Pongchalee">
                </div>
                <div class="about-text">
                    <h2 class="section-title">About Me</h2>
                    <p class="section-subtitle">
                        My work bridges the gap between theoretical physics and practical application, from simulating novel light sources to developing the tools that power real-world experiments.
                    </p>
                    <p>
                        As a Beamline Scientist at the <strong>Synchrotron Light Research Institute (SLRI)</strong>, I design, develop, and operate advanced beamline instrumentation. I apply sophisticated synchrotron techniques to diverse research challenges and collaborate with scientists to turn experimental concepts into reality. This role demands a deep, practical understanding of how light interacts with matter.
                    </p>
                    <h3>Foundation in Computational Physics</h3>
                    <p>
                        My work is built on a strong foundation in computational physics from my Ph.D. at the <strong>University of Strathclyde</strong>. My research focused on creating comprehensive simulations of Free-Electron Lasers (FELs) by integrating FEL dynamics with optical propagation codes. This allowed me to validate novel models for cavity-based FELs, providing key insights for developing next-generation light sources.
                    </p>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 P. Pongchalee. All Rights Reserved.</p>
        </div>
    </footer>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
        // --- Renderer ---
        const scene = new THREE.Scene();
        const canvas = document.getElementById('wiggler-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(window.innerWidth, window.innerHeight, false);

        // --- Parameters ---
        const magnetCount = 20;
        const magnetSpacing = 2.0;
        const undulatorWidth = (magnetCount - 1) * magnetSpacing;
        const startX = -undulatorWidth / 2;
        const undulatorLambda = 2.0 * magnetSpacing; // one full oscillation in x

        const amplitude = 0.25;
        const frequency = Math.PI / magnetSpacing; // y(x) = A cos(frequency * x)
        const electronSpeed = 5;            // electron forward speed

        // Circle emission & animation parameters (tuned)
        const circleSpeedFactor = 0.65;     // circle moves slightly faster than electron
        const circleSpeed = electronSpeed * circleSpeedFactor;
        const ringR0 = 0.2;                // initial radius (slightly bigger than electron ~0.15)
        const ringGrowthSpeed = 2.0;        // how fast radius increases (units/sec)
        const ringLifespan = 7.0;           // longer life (seconds)
        const ringMaxCount = 100;            // keep only the most recent N circles
        const ringThickness = 0.008;        // *** thinner band ***

        // --- 2D Orthographic Camera (auto-fit) ---
        let camera;
        function fitOrthoCamera() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const aspect = w / h;

        // Horizontal extents: undulator + margins so first/last period are visible
        const xMargin = 0.6 * magnetSpacing;
        const xMin = startX - xMargin;
        const xMax = startX + undulatorWidth + xMargin;
        const halfWidth = 0.5 * (xMax - xMin);

        // Vertical extents: include magnets and max ring expansion
        const maxRingRadius = ringR0 + ringGrowthSpeed * ringLifespan + ringThickness;
        const magnetTopEdge = 1.5 + 0.75 * 0.5;
        const magnetBottomEdge = -2.5 - 0.75 * 0.5;
        const yMargin = 0.25;
        const yHalfNeeded = Math.max(
            Math.abs(magnetTopEdge),
            Math.abs(magnetBottomEdge),
            Math.abs(amplitude) + maxRingRadius
        ) + yMargin;

        const halfHeightFromX = halfWidth / aspect;
        const viewHalfHeight = Math.max(yHalfNeeded, halfHeightFromX);
        const viewHalfWidth  = viewHalfHeight * aspect;

        if (!camera) {
            camera = new THREE.OrthographicCamera(
            -viewHalfWidth, viewHalfWidth,
            viewHalfHeight, -viewHalfHeight,
            -100, 100
            );
        } else {
            camera.left   = -viewHalfWidth;
            camera.right  =  viewHalfWidth;
            camera.top    =  viewHalfHeight;
            camera.bottom = -viewHalfHeight;
            camera.updateProjectionMatrix();
        }
        camera.position.set((xMin + xMax)/2, 0, 10);
        camera.lookAt((xMin + xMax)/2, 0, 0);
        }
        fitOrthoCamera();

        // --- Magnets (2D rectangles) ---
        const magnetGroup = new THREE.Group();
        const magW = 0.75, magH = 0.75;
        const planeGeom = new THREE.PlaneGeometry(magW, magH);
        const redMat  = new THREE.MeshBasicMaterial({ color: 0xff5555 });
        const blueMat = new THREE.MeshBasicMaterial({ color: 0x5555ff });
        for (let i = 0; i < magnetCount; i++) {
        const xPos = startX + i * magnetSpacing;
        const topIsRed = i % 2 === 0;
        const up = new THREE.Mesh(planeGeom, topIsRed ? redMat : blueMat);
        up.position.set(xPos,  1.5, 0);
        magnetGroup.add(up);
        const dn = new THREE.Mesh(planeGeom, topIsRed ? blueMat : redMat);
        dn.position.set(xPos, -2.5, 0);
        magnetGroup.add(dn);
        }
        scene.add(magnetGroup);

        // --- Electron (2D circle) ---
        const electron = new THREE.Mesh(
        new THREE.CircleGeometry(0.15, 32),
        new THREE.MeshBasicMaterial({ color: '#00BFFF' })
        );
        scene.add(electron);

        // --- Thin Ring template ---
        function makeRingMesh() {
        const geom = new THREE.RingGeometry(ringR0 - ringThickness, ringR0 + ringThickness, 256);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            transparent: true,
            opacity: 0.95,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        return new THREE.Mesh(geom, mat);
        }

        // --- Circle (ring) instance state ---
        const rings = []; // { mesh, birthTime, birthAbsX }
        let lastEmittedPeriodIndex = -1;

        // --- Helpers for wrapping x into visible window ---
        function wrapToWindow(absX) {
        const mod = ((absX - startX) % undulatorWidth + undulatorWidth) % undulatorWidth;
        return startX + mod;
        }

        // --- Animation ---
        const clock = new THREE.Clock();
        function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();

        // Electron absolute distance
        const absDist = t * electronSpeed;
        const eProgress = absDist % undulatorWidth;
        const x_e = startX + eProgress;
        const y_e = amplitude * Math.cos(frequency * eProgress);
        electron.position.set(x_e, y_e, 0);

        // Emit a new ring once per undulator period
        const periodIndex = Math.floor(absDist / undulatorLambda);
        if (periodIndex !== lastEmittedPeriodIndex) {
            lastEmittedPeriodIndex = periodIndex;
            const ring = makeRingMesh();
            ring.userData.birthTime = t;
            ring.userData.birthAbsX = x_e; // absolute x at emission
            scene.add(ring);
            rings.push(ring);
            if (rings.length > ringMaxCount) {
            const old = rings.shift();
            scene.remove(old);
            old.geometry.dispose();
            old.material.dispose();
            }
        }

        // Update rings
        for (let i = rings.length - 1; i >= 0; i--) {
            const r = rings[i];
            const age = t - r.userData.birthTime;

            // Motion along x with slight lead
            const x_abs = r.userData.birthAbsX + circleSpeed * age;
            const x_loc = wrapToWindow(x_abs);
            const y_loc = amplitude * Math.cos(frequency * ((x_loc - startX) % undulatorWidth));
            r.position.set(x_loc, y_loc, 0);

            // Expansion
            const radius = ringR0 + ringGrowthSpeed * age;
            const scale = radius / ringR0;
            r.scale.set(scale, scale, 1);

            // Slower, easeâ€‘out fading (stays brighter longer)
            const u = Math.min(1, age / ringLifespan);
            const easeOut = 1.0 - Math.pow(u, 1.5); // bias brightness toward early life
            r.material.opacity = 0.95 * easeOut;

            // Cleanup when fully faded
            if (u >= 1.0) {
            scene.remove(r);
            rings.splice(i, 1);
            r.geometry.dispose();
            r.material.dispose();
            }
        }

        renderer.render(scene, camera);
        }

        // --- Resize handling ---
        function onResize() {
        renderer.setSize(window.innerWidth, window.innerHeight, false);
        fitOrthoCamera();
        }
        window.addEventListener('resize', onResize, false);
        onResize();
        animate();
    </script>
</body>
</html>
