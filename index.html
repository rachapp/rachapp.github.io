<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P. Pongchalee | Physicist & Researcher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Styles for the new About Me section with Avatar --- */
        #about .about-container {
            display: flex;
            align-items: flex-start;
            gap: 50px;
        }

        #about .about-avatar {
            flex-shrink: 0;
            text-align: center;
        }

        #about .about-avatar img {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 3px solid var(--primary-color);
            background-color: var(--bg-content);
            padding: 5px;
        }
        
        #about .about-text .section-title,
        #about .about-text .section-subtitle {
            text-align: left;
            margin-left: 0;
            margin-right: 0;
            max-width: 100%;
        }

        #about .about-text h3 {
            margin-top: 1.5rem;
            color: var(--primary-color);
        }

        /* --- Styles for the WebGL Canvas --- */
        #hero {
            position: relative; /* Needed for absolute positioning of canvas */
            overflow: hidden; /* Hide anything that goes outside the hero area */
        }

        #wiggler-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Place canvas behind the text */
        }

        #hero .container {
            position: relative; /* Ensure text container is on top */
            z-index: 2;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #about .about-container {
                flex-direction: column;
                align-items: center;
                gap: 30px;
            }

            #about .about-text .section-title,
            #about .about-text .section-subtitle {
                text-align: center;
            }
        }
    </style>
</head>
<body style="background-color: var(--bg-main);">

    <header class="navbar">
        <div class="container">
            <a href="index.html" class="logo">P. Pongchalee</a>
            <nav>
                <ul class="nav-links">
                    <li><a href="index.html" class="active">Home</a></li>
                    <li><a href="research.html">Research</a></li>
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <!-- Hero Section with WebGL Canvas -->
        <section id="hero">
            <canvas id="wiggler-canvas"></canvas>
            <div class="container">
                <h1>Advancing Science with Light & Code</h1>
                <p class="section-subtitle" style="color: white; font-size: 1.2rem;">A physicist specializing in synchrotron instrumentation and computational modeling to develop and optimize next-generation light sources..</p>
            </div>
        </section>

        <!-- About Section -->
        <section id="about">
            <div class="container about-container">
                <div class="about-avatar">
                    <img
                        src="https://api.dicebear.com/9.x/micah/svg?seed=Leah&baseColor=ac6651&eyeShadowColor=ffedef&eyebrows=up&glasses=round&glassesColor=000000&glassesProbability=100&hair=fonze&hairColor=000000&mouth=laughing,nervous,smile,surprised,smirk&shirt=open"
                        alt="avatar for P. Pongchalee" />
                </div>
                <div class="about-text">
                    <h2 class="section-title">About Me</h2>
                    <p class="section-subtitle">
                        My work bridges the gap between theoretical physics and practical application, from simulating novel light sources to developing the tools that power real-world experiments.
                    </p>
                    <p>
                        As a Beamline Scientist at the <strong>Synchrotron Light Research Institute (SLRI)</strong>, I design, develop, and operate advanced beamline instrumentation. I apply sophisticated synchrotron techniques to diverse research challenges and collaborate with scientists to turn experimental concepts into reality. This role demands a deep, practical understanding of how light interacts with matter.
                    </p>
                    <h3>Foundation in Computational Physics</h3>
                    <p>
                        My work is built on a strong foundation in computational physics from my Ph.D. at the <strong>University of Strathclyde</strong>. My research focused on creating comprehensive simulations of Free-Electron Lasers (FELs) by integrating FEL dynamics with optical propagation codes. This allowed me to validate novel models for cavity-based FELs, providing key insights for developing next-generation light sources.
                    </p>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 P. Pongchalee. All Rights Reserved.</p>
        </div>
    </footer>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
        // --- Renderer ---
        const scene = new THREE.Scene();
        const canvas = document.getElementById('wiggler-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(window.innerWidth, window.innerHeight, false);

        // --- Parameters ---
        const magnetCount   = 30;
        const magnetSpacing = 2.0;
        const undulatorWidth = (magnetCount - 1) * magnetSpacing; // module length
        const startX = -undulatorWidth / 2;
        const endX   =  startX + undulatorWidth;
        const undulatorLambda = 2.0 * magnetSpacing;

        // Place magnet rows symmetrically about y=0 so the electron center is in the middle
        const magnetYTop    =  2.0;
        const magnetYBottom = -2.0;
        const yCenter = 0.5 * (magnetYTop + magnetYBottom); // = 0.0

        // Make magnets wider: almost no gap between adjacent magnets
        const gapFraction = 0.04;                          // 4% gap of spacing
        const magW = magnetSpacing * (1.0 - gapFraction);  // very small gap
        const magH = 0.9;                                   // a touch taller than before

        // Electron oscillation
        const amplitude = 0.25;                             // about the center between rows
        const k = Math.PI / magnetSpacing;                  // = 2π / λ_u
        const electronSpeed = 10.0;

        // Drift settings (outside module)
        const driftLeft  = 6.0;
        const driftRight = 6.0;
        const edgeBlend  = 0.6;   // smooth transition width

        // Loop reset (off-screen)
        const offscreenPad = 8.0;

        // Circles
        const circleSpeedFactor = 0.87;
        const circleSpeed = electronSpeed * circleSpeedFactor;
        const ringR0 = 0.3;
        const ringGrowthSpeed = 2.0;
        const ringLifespan = 5.0;
        const ringMaxCount = 50;
        const ringThickness = 0.01;
        const fadeExponent = 1.5;
        const startOpacity = 0.85;

        // --- Camera (fit everything) ---
        let camera;
        function fitOrthoCamera(){
        const w = canvas.clientWidth, h = canvas.clientHeight, aspect = w/h;

        const xMinScene = startX - driftLeft;
        const xMaxScene = endX   + driftRight;
        const halfWidth = 0.5 * (xMaxScene - xMinScene);

        const maxRingRadius = ringR0 + ringGrowthSpeed * ringLifespan + ringThickness;
        const magnetTopEdge = magnetYTop + magH * 0.5;
        const magnetBottomEdge = magnetYBottom - magH * 0.5;
        const yHalfNeeded = Math.max(Math.abs(magnetTopEdge), Math.abs(magnetBottomEdge), Math.abs(yCenter) + amplitude + maxRingRadius) + 0.25;

        const viewHalfHeight = Math.max(yHalfNeeded, halfWidth/aspect);
        const viewHalfWidth  = viewHalfHeight * aspect;

        if (!camera) camera = new THREE.OrthographicCamera(-viewHalfWidth, viewHalfWidth, viewHalfHeight, -viewHalfHeight, -100, 100);
        else { camera.left=-viewHalfWidth; camera.right=viewHalfWidth; camera.top=viewHalfHeight; camera.bottom=-viewHalfHeight; camera.updateProjectionMatrix(); }
        camera.position.set((xMinScene+xMaxScene)/2, 0, 10); camera.lookAt((xMinScene+xMaxScene)/2, 0, 0);
        }
        fitOrthoCamera();

        // --- Magnets (2D) ---
        const magnetGroup = new THREE.Group();
        const planeGeom = new THREE.PlaneGeometry(magW, magH);
        const redMat  = new THREE.MeshBasicMaterial({
            color: 0xff5555,
            transparent: true,
            opacity: 0.5,      // <-- alpha
            depthWrite: false   // optional: helps avoid sorting artifacts with transparency
        });
        const blueMat = new THREE.MeshBasicMaterial({
            color: 0x5555ff,
            transparent: true,
            opacity: 0.5,
            depthWrite: false
        });
        for (let i=0;i<magnetCount;i++){
        const x = startX + i*magnetSpacing;
        const topIsRed = i%2===0;
        const up = new THREE.Mesh(planeGeom, topIsRed?redMat:blueMat);
        up.position.set(x, magnetYTop, 0); magnetGroup.add(up);
        const dn = new THREE.Mesh(planeGeom, topIsRed?blueMat:redMat);
        dn.position.set(x, magnetYBottom, 0); magnetGroup.add(dn);
        }
        scene.add(magnetGroup);

        // --- Electron ---
        const electron = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), new THREE.MeshBasicMaterial({ color:'#00BFFF' }));
        scene.add(electron);

        // --- Ring factory ---
        function makeRing(){
        const geom = new THREE.RingGeometry(ringR0 - ringThickness, ringR0 + ringThickness, 256);
        const mat  = new THREE.MeshBasicMaterial({ color:0xffd700, transparent:true, opacity:startOpacity, depthWrite:false, blending:THREE.AdditiveBlending, side:THREE.DoubleSide });
        const mesh = new THREE.Mesh(geom, mat);
        scene.add(mesh);
        return mesh;
        }

        // --- Helpers ---
        function clamp01(x){ return Math.max(0, Math.min(1, x)); }
        function smoothstep(e0, e1, x){ const t = clamp01((x-e0)/(e1-e0)); return t*t*(3.0 - 2.0*t); }

        // y(x_abs): cosine inside module around yCenter; straight (≈yCenter) outside with smooth edges
        function yPath(x_abs){
        const gateIn  = smoothstep(startX,       startX + edgeBlend, x_abs);
        const gateOut = 1.0 - smoothstep(endX - edgeBlend, endX,     x_abs);
        const gate = Math.min(gateIn, gateOut);
        return yCenter + gate * amplitude * Math.cos(k * (x_abs - startX));
        }

        // --- State ---
        const rings = []; // { mesh, birthTime, birthAbsX }
        let lastPeriodIdx = -1;
        let x0 = startX - driftLeft - offscreenPad;
        let t0 = 0;

        // --- Animation ---
        const clock = new THREE.Clock();
        function animate(){
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        const x_abs_e = x0 + electronSpeed*(t - t0);
        const y_e = yPath(x_abs_e);
        electron.position.set(x_abs_e, y_e, 0);

        // Emit rings only inside module
        if (x_abs_e >= startX && x_abs_e <= endX) {
            const periodsFromLeft = (x_abs_e - startX) / undulatorLambda;
            const periodIdx = Math.floor(periodsFromLeft + 1e-6);
            if (periodIdx !== lastPeriodIdx){
            lastPeriodIdx = periodIdx;
            const ring = makeRing();
            ring.userData.birthTime = t;
            ring.userData.birthAbsX = x_abs_e;
            rings.push(ring);
            if (rings.length > ringMaxCount){ const old = rings.shift(); cleanupRing(old); }
            }
        } else {
            lastPeriodIdx = -1;
        }

        // Update rings
        for (let i=rings.length-1; i>=0; i--){
            const r = rings[i];
            const age = t - r.userData.birthTime;

            const x_abs = r.userData.birthAbsX + circleSpeed * age;
            const y     = yPath(x_abs);
            r.position.set(x_abs, y, 0);

            const radius = ringR0 + ringGrowthSpeed * age;
            const scale  = radius / ringR0;
            r.scale.set(scale, scale, 1);

            const u = Math.min(1, age / ringLifespan);
            const easeOut = 1.0 - Math.pow(u, fadeExponent);
            r.material.opacity = Math.max(0.0, startOpacity * easeOut);

            if (u >= 1){ cleanupRing(r); rings.splice(i,1); }
        }

        // Loop reset when far to the right
        const sceneRight = endX + driftRight;
        if (x_abs_e > sceneRight + offscreenPad){
            x0 = startX - driftLeft - offscreenPad;
            t0 = t;
        }

        renderer.render(scene, camera);
        }

        function cleanupRing(r){ scene.remove(r); r.geometry.dispose(); r.material.dispose(); }

        // --- Resize ---
        function onResize(){ renderer.setSize(window.innerWidth, window.innerHeight, false); fitOrthoCamera(); }
        window.addEventListener('resize', onResize, false);
        onResize();
        animate();
    </script>
</body>
</html>
